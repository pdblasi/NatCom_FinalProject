% !TEX root = FinalProject.tex

\chapter{Solution}

\section{Phase 1 - Design Approach}
	% Talk about initial design of game system/rules
	% Mention client/server architecture, and decisions to develop
	%  server from algorithm to network, and
	%  client from GUI to algorithm to network.

When starting out on this project, all that we knew is that we wanted to make a
game based in Natural Computing. We realized very early that an evolutionary
algorithm would be essential to create dynamicism in the game and ensure it was not
a simple, repetitive program. However, an evolutionary algorithm alone would not be
quite enough. We played around with the idea of putting the animals on a grid, to
allow them to interact with one another and explore the area. \\
Fortunately, we had this realization at about the time that the class was covering
Ant Colonies. The idea of pheromones was quickly snatched up.

When the class covered Cellular Automata, we realized that what we were building
would work very well in this sort of architecture. Our ``CA" cheated a little;
rather than depending solely on neighboring positions and states, we look at
neighborhoods to find competitors and randomly decide what happens after that,
based on a simple rule set and the players' settings.

At about the same time, the idea of splitting the project into a client-server
architecture began to hold more promise. With this sort of design, we could
distribute the individual EAs amongst the clients, with each being responsible for
evolving its own creatures. The server, meanwhile, would poll their statistics and
run the grid simulation to determine whether any of the creatures had conflict.

Once we decided our architecture, we moved on to considering how to build the 
client and server. Since they were communicating over the network, they need not
use the same language. We discussed the possibilities at length, initially 
considering Python for everything, but worrying that it would not be quite fast
enough for the server's purpose. Thus, we decided that C++ would better suit the
server, since it had no graphical requirements and would need as much speed as it
could get. The client, however, would be better off with visuals, so Python is the
language we chose for that. (We did consider whether the EA would move quickly
enough; in the end, we decided that we would try, and convert to C++ later if need
be.) \\
With the basic design considerations in place, we broke up the work -- Jaysen
offered to build the server, and Paul was happy to work on the client.

Finally, before any actual development could begin, we needed to know what our
program would actually do. Paul already had many ideas for the program. The rules
would focus entirely on the low-level agents in the simulation: they would have
certain mentalities and abilities, and act randomly with weights based on their
attributes.
\begin{description}
    \item[Prey v. Predator] This mentality determines how likely an agent is to
        seek out locations that contain other species.
    \item[Group v. Lone] This mentality determines how likely an agent is to seek
        out locations that contain their own species.
    \item[Strength v. Speed] This ability determines which reaction an agent will
        give in conflict, and how likely they are to succeed with it.
    \item[Lifetime v. Reproduction] This attribute determines whether a species is
        more likely to live a longer time, or to produce more children.
    \item[Senses] This attribute determines how likely an agent is to see another
        agent on the grid.
\end{description}
Meanwhile, Jaysen had several ideas for the implementation of the game.
\begin{description}
    \item[Pheromones] An idea borrowed from Ant Colonies, pheromones would be used
        to track where agents had been in the grid. This would play in with the
        different mentalities involving movement based on other agents.
    \item[Roulette] An idea borrowed from Evolutionary Algorithms, a roulette
        selection would be the tool of choice for determining the results of
        conflicts. Each agent would be weighted accordingly, by their relevant
        attribute.
    \item[Grid Tracking] Directly used from Cellular Automata, the idea of tracking
        agents in a common grid is almost a necessity for neighborhood checking.
    \item[Agent Tracking] In addition to CA's mapping, we will use the idea of
        tracking individual agents from Particle Swarms. This will increase the
        memory space requirements for the program, but on a server model, speed is
        more important.
\end{description}

Thus, we were ready to begin constructing the project.

\section{Phase 2 - Prototype $\alpha$}
	% Talk about initial steps taken in design.
	% Server was a mish-mash of code to get a running ``CA''
	% Client was a sandbox GUI to figure out program structuring approach
Once the design had been sufficiently fleshed out, we began working on our 
respective project components. This initial prototype is simply an effort to get
our thoughts put into code on our algorithms, which will allow us to create a
better structure later on and help decide what is needed in network communication.

\subsection{The Server}
The initial phase of the server was simply algorithm creation. Jaysen implemented
a number of functions to initialize a set of variables, so that he would have some
sample data to run the program with.

\subsection{The Client}
    % Paul! The client's initial GUI phase?

\section{Phase 2 - Prototype $\beta$}
	% Talk about next steps taken in design.
	% Server was modularized and broken down into classes
	% Client solified MVC pattern and developed algorithms
After the initial phase was finished, we went back into our code to clean things up
and create some modularity. This would allow us to address any issues that we
discovered with our now-running algorithms without having to delve through massive
functions.

\subsection{The Server}
Jaysen opted to break the functionality up by creating an ``Engine" class, which
encapsulates the algorithm and hides components that aren't needed in general.

\subsection{The Client}
    % Paul! The EA?

\section{Phase 3 - Networking Structure}
	% Discuss networking structure (agreed-upon transmission protocol)
Once the algorithms had been implemented and we understood exactly what we needed
from the other application, it was easy enough to construct a protocol for message
passing over the network. The basic format of a message is as follows.

[1-byte message type] [4-byte message length, N] [N-byte message]

Message type may be one of the following.
\begin{description}
    \item[READY (0)] The message relates to the readiness of a client to begin.
    \item[PLAYER\_UPDATE (1)] The message relates to an update in the player list.
    \item[INDEX (2)] The message relates to an update in the player's settings.
    \item[ENGINE (3)] The message relates to the game itself.
    \item[VICTORY (4)] The message declares a winner of the game.
\end{description}

As a result of this definition, Paul and Jaysen agreed to create modular components
to handle network communication.

\subsection{The Server}
In this phase, the server became three large components.
\begin{description}
    \item[ServerLobby] This class is called upon when the server initially starts
        up. It is responsible for handling network setup: specifically, accepting
        new connections, pruning disconnected clients, and receiving readiness
        messages as well as color preferences.
    \item[ServerComm] This class is the core of the server's network
        communication. It abstracts the basic socket mechanisms, allowing
        callers to send and receive ``packets" of data directly.
    \item[ServerEngine] This class is started once the server is set up. It is
        responsible for advancing the game and checking for winning conditions,
        as well as maintaining communication with the players to send and
        receive progress updates.
\end{description}

\subsection{The Client}
    % Paul! It got complex here, didn't it?

\section{Phase 4 - Testing and Review}
	% Not here quite yet.
As of this writing, the server and client are not a complete application. The
algorithms and underlying network components are functioning, but the
inter-program communication is not up and running. \\
Thus, the result of this project venture is untested.
